from pyrogram import filters
from pyrogram.types import Message
from pyrogram import Client, filters
from pyrogram.types import ChatMember
import asyncio
from pyrogram.types import *
from pymongo import MongoClient
import requests
import random
from pyrogram.errors import (
    PeerIdInvalid,
    ChatWriteForbidden
)
from pytgcalls import PyTgCalls
from pytgcalls import PyTgCalls, StreamType
from pytgcalls.exceptions import (
    AlreadyJoinedError,
    NoActiveGroupCall,
    TelegramServerError,
)
from pytgcalls.types import Update
from pytgcalls.types.input_stream import AudioPiped, AudioVideoPiped
from pytgcalls.types.input_stream.quality import HighQualityAudio, MediumQualityVideo
from pytgcalls.types.stream import StreamAudioEnded

from pyrogram.errors import ChatAdminRequired, UserNotParticipant, ChatWriteForbidden
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message
from pyrogram.errors import ChatAdminRequired, UserNotParticipant, ChatWriteForbidden
import os
import re
from PIL import ImageDraw, Image, ImageFont, ImageChops
from pyrogram import *
from pyrogram.types import *

API_ID = "6435225"
API_HASH = "4e984ea35f854762dcde906dce426c2d"
STRING = os.environ.get("STRING", "")
MONGO_URL = os.environ.get("MONGO_URL", "mongodb+srv://kuldiprathod2003:kuldiprathod2003@cluster0.wxqpikp.mongodb.net/?retryWrites=true&w=majority")

client = Client(STRING, API_ID, API_HASH)
AMTAGS= [
    "á´ÉªÉª á´€á´Ê™á´á´› á´‹á´ á´›á´€É¢ á´á´€á´›á´› á´‹á´€Ê€á´ á´¡á´ á´€Ê™ Ê™á´œêœ±Ê Êœá´‡",
    "ğ“  ğ”‚ğ“ªğ“ªğ“­ ğ“šğ“ªğ“»ğ“»ğ“±ğ“® ğ“±ğ“¸ ğ“ğ“œğ“‘ğ“ğ“£ ğ“šğ“¸",
    "ğ˜¼ğ™ˆğ˜½ğ™Šğ™ ğ˜¾ğ™–ğ™¡ğ™¡ ğ™‹ğ™š ğ™ƒğ™š ğ˜¼ğ™— ğ™’ğ™¤ ğ™ˆğ™šğ™§ğ™š ğ™ğ™–ğ™©ğ™",
    "á´‹á´Éª Éªêœ±á´‹á´ @AM_YTBOTT É¢êœ° á´…ÉªÊŸá´€á´…á´..ğŸ˜¢ğŸ˜¢ğŸ˜¢",
    "ğ˜¼ğ™— ğ˜¼ğ™— ğ™Šğ™›ğ™¡ğ™ğ™£ğ™š ğ™‚ğ™–ğ™®ğ™– ğ™’ğ™¤ ğ™…ğ™–ğ™¤ ğ˜¾ğ™–ğ™¡ğ™¡ ğ™†ğ™–ğ™§ğ™¡ğ™¤ ğ™–ğ™–ğ™Ÿğ™–ğ™®ğ™– ğ™œğ™– ğ™Šğ™£ğ™¡ğ™ğ™£ğ™š ğŸ˜œğŸ˜œ"
]
AAA = [
    "Nahi Me To Cute Mikashaa hu â˜ºï¸ğŸ˜Š",
    "Tumko Kya Lagta He ğŸ˜¢ğŸ˜’",
    "Nahi U Bot ğŸ˜‚",
    "Are Kuch V ğŸ˜³ğŸ˜‚",
    "Puch Lo AMBOT Se Me Kon Hu ğŸ™ˆ",
    "Me Insaan Hu Reee Aaj Tumko Pitna He sayad ğŸ˜",
]
sudos = 6204761408
REPO = """á´Éªá´‹á´€sÊœá´€á´€ á´€ÉªâŒ«

<u>ğ—–ğ—¥ğ—˜ğ——ğ—œğ—§ â¥ï¸ á´€á´Ê™á´á´›:</u>

ğ—¥ğ—˜ğ—£ğ—¢ â¥ï¸ [ğ—¥ğ—˜ğ—£ğ—¢](t.me/About_AMBot)

ğ—–ğ—›ğ—”ğ—¡ğ—¡ğ—˜ğ—Ÿ â¥ï¸ [É¢Ê™á´€É´êœ± ÊŸá´É¢êœ±](https://t.me/Logs_Gban)

ğ—¢ğ—ªğ—¡ğ—˜ğ—¥ â¥ï¸ [á´€á´Ê™á´á´›](https://t.me/AM_YTBOTT)"""
HELP = "Êœá´‡Ê€á´‡ Éªêœ± á´„á´á´…êœ± êœ°á´Ê€ á´›á´€É¢á´€ÊŸÊŸ\ná´œêœ±á´‡ á´„á´á´…êœ± á´˜Ê€á´‡êœ°Éªxá´‡êœ± : `.` `/` `?` `!` -\ná´œêœ±á´‡Ê€,ÉªÉ´á´ Éªá´›á´‡ - á´›á´ Ê€á´€É´á´…á´á´ á´›á´€É¢êœ± á´›á´ á´œêœ±á´‡Ê€êœ±\n\ná´„á´€É´á´„ÊŸá´‡,êœ±á´›á´á´˜á´€ÊŸÊŸ,á´êœ°êœ° - á´›á´ á´›á´€É¢á´€ÊŸÊŸ êœ±á´›á´á´˜\n\ná´‡xá´€á´á´˜ÊŸá´‡êœ± : `user hii` \nêœ°á´Ê€ êœ±á´›á´á´˜ á´›á´€É¢êœ± á´œêœ±á´‡ : `off`"
SPAM_CHATS = []
TAGMES = [ " **ğ‡ğğ² ğğšğ›ğ² ğŠğšğ¡ğš ğ‡ğ¨ğŸ¥±** ",
           " **ğğ²ğ ğ’ğ¨ ğ†ğ²ğ ğŠğ²ğš ğğ§ğ¥ğ¢ğ§ğ ğ€ğšğ¨ğŸ˜Š** ",
           " **ğ•ğœ ğ‚ğ¡ğšğ¥ğ¨ ğğšğ­ğğ§ ğŠğšğ«ğ­ğ ğ‡ğšğ¢ğ§ ğŠğ®ğœğ¡ ğŠğ®ğœğ¡ğŸ˜ƒ** ",
           " **ğŠğ¡ğšğ§ğš ğŠğ¡ğš ğ‹ğ¢ğ²ğ ğ‰ğ¢..??ğŸ¥²** ",
           " **ğ†ğ¡ğšğ« ğŒğ ğ’ğšğ› ğŠğšğ¢ğ¬ğ ğ‡ğšğ¢ğ§ ğ‰ğ¢ğŸ¥º** ",
           " **ğğ­ğš ğ‡ğšğ¢ ğğ¨ğ¡ğ¨ğ­ ğŒğ¢ğ¬ğ¬ ğŠğšğ« ğ‘ğ¡ğ¢ ğ“ğ¡ğ¢ ğ€ğšğ©ğ¤ğ¨ğŸ¤­** ",
           " **ğğ²ğ ğ‡ğšğ¥ ğ‚ğ¡ğšğ¥ ğŠğğ¬ğš ğ‡ğšğ¢..??ğŸ¤¨** ",
           " **ğŒğğ«ğ¢ ğğ¡ğ¢ ğ’ğğ­ğ­ğ¢ğ§ğ  ğŠğšğ«ğ›ğš ğƒğ¨ğ ğ..??ğŸ™‚** ",
           " **ğ€ğšğ©ğ¤ğš ğğšğ¦ğ ğŠğ²ğš ğ¡ğšğ¢..??ğŸ¥²** ",
           " **ğğšğ¬ğ­ğš ğ‡ğ®ğš ğ€ğšğ©ğ¤ğš..??ğŸ˜‹** ",
           " **ğŒğğ«ğ ğŠğ¨ ğ€ğ©ğ§ğ ğ†ğ«ğ¨ğ®ğ© ğŒğ ğŠğ¢ğğ§ğšğ© ğŠğ« ğ‹ğ¨ğŸ˜** ",
           " **ğ€ğšğ©ğ¤ğ¢ ğğšğ«ğ­ğ§ğğ« ğ€ğšğ©ğ¤ğ¨ ğƒğ¡ğ®ğ§ğ ğ‘ğ¡ğ ğ‡ğšğ¢ğ§ ğ‰ğ¥ğğ¢ ğğ§ğ¥ğ¢ğ§ğ ğ€ğ²ğ¢ğšğğŸ˜…ğŸ˜…** ",
           " **ğŒğğ«ğ ğ’ğ ğƒğ¨ğ¬ğ­ğ¢ ğŠğ«ğ¨ğ ğ..??ğŸ¤”** ",
           " **ğ’ğ¨ğ§ğ ğ‚ğ¡ğšğ¥ ğ†ğ²ğ ğŠğ²ğšğŸ™„ğŸ™„** ",
           " **ğ„ğ¤ ğ’ğ¨ğ§ğ  ğğ¥ğšğ² ğŠğ«ğ¨ ğğš ğğ¥ğ¬ğ¬ğŸ˜•** ",
           " **ğ€ğšğ© ğŠğšğ¡ğš ğ’ğ ğ‡ğ¨..??ğŸ™ƒ** ",
           " **ğ‡ğğ¥ğ¥ğ¨ ğ‰ğ¢ ğğšğ¦ğšğ¬ğ­ğğŸ˜›** ",
           " **ğ‡ğğ¥ğ¥ğ¨ ğğšğ›ğ² ğŠğ¤ğ«ğ¡..?ğŸ¤”** ",
           " **ğƒğ¨ ğ˜ğ¨ğ® ğŠğ§ğ¨ğ° ğ–ğ¡ğ¨ ğˆğ¬ ğŒğ² ğğ°ğ§ğğ«.?** ",
           " **ğ‚ğ¡ğ¥ğ¨ ğŠğ®ğœğ¡ ğ†ğšğ¦ğ ğŠğ¡ğğ¥ğ­ğ ğ‡ğšğ¢ğ§.ğŸ¤—** ",
           " **ğ€ğ®ğ« ğğšğ­ğšğ¨ ğŠğšğ¢ğ¬ğ ğ‡ğ¨ ğğšğ›ğ²ğŸ˜‡** ",
           " **ğ“ğ®ğ¦ğ¡ğšğ«ğ¢ ğŒğ®ğ¦ğ¦ğ² ğŠğ²ğš ğŠğšğ« ğ‘ğšğ¡ğ¢ ğ‡ğšğ¢ğŸ¤­** ",
           " **ğŒğğ«ğ ğ’ğ ğğšğ­ ğğ¨ğ¢ ğŠğ«ğ¨ğ ğğŸ¥ºğŸ¥º** ",
           " **ğğ²ğ ğğšğ ğšğ¥ ğğ§ğ¥ğ¢ğ§ğ ğ€ğš ğ‰ğšğŸ˜¶** ",
           " **ğ€ğšğ£ ğ‡ğ¨ğ¥ğ¢ğğšğ² ğ‡ğšğ¢ ğŠğ²ğš ğ’ğœğ¡ğ¨ğ¨ğ¥ ğŒğ..??ğŸ¤”** ",
           " **ğğ²ğ ğ†ğ¨ğ¨ğ ğŒğ¨ğ«ğ§ğ¢ğ§ğ ğŸ˜œ** ",
           " **ğ’ğ®ğ§ğ¨ ğ„ğ¤ ğŠğšğ¦ ğ‡ğšğ¢ ğ“ğ®ğ¦ğ¬ğğŸ™‚** ",
           " **ğŠğ¨ğ¢ ğ’ğ¨ğ§ğ  ğğ¥ğšğ² ğŠğ«ğ¨ ğğšğŸ˜ª** ",
           " **ğğ¢ğœğ ğ“ğ¨ ğŒğğğ­ ğ”ğ¡â˜º** ",
           " **ğ‡ğğ¥ğ¥ğ¨ğŸ™Š** ",
           " **ğ’ğ­ğ®ğğ² ğ‚ğ¨ğ¦ğ¥ğğ­ğ ğ‡ğ®ğš??ğŸ˜º** ",
           " **ğğ¨ğ¥ğ¨ ğğš ğŠğ®ğœğ¡ ğ˜ğ«ğ«ğŸ¥²** ",
           " **ğ’ğ¨ğ§ğšğ¥ğ¢ ğŠğ¨ğ§ ğ‡ğšğ¢...??ğŸ˜…** ",
           " **ğ“ğ®ğ¦ğ¡ğšğ«ğ¢ ğ„ğ¤ ğğ¢ğœ ğŒğ¢ğ¥ğğ ğ¢..?ğŸ˜…** ",
           " **ğŒğ®ğ¦ğ¦ğ² ğ€ğš ğ†ğ²ğ¢ ğŠğ²ğšğŸ˜†ğŸ˜†ğŸ˜†** ",
           " **ğğ« ğğšğ­ğšğ¨ ğğ¡ğšğ›ğ¡ğ¢ ğŠğšğ¢ğ¬ğ¢ ğ‡ğšğ¢ğŸ˜‰** ",
           " **ğˆ ğ‹ğ¨ğ¯ğ ğ˜ğ¨ğ®ğŸ™ˆğŸ™ˆğŸ™ˆ** ",
           " **ğƒğ¨ ğ˜ğ¨ğ® ğ‹ğ¨ğ¯ğ ğŒğ..?ğŸ‘€** ",
           " **ğ‘ğšğ¤ğ¡ğ¢ ğŠğšğ› ğğšğ§ğ ğ‘ğšğ¡ğ¢ ğ‡ğ¨.??ğŸ™‰** ",
           " **ğ„ğ¤ ğ’ğ¨ğ§ğ  ğ’ğ®ğ§ğšğ®..?ğŸ˜¹** ",
           " **ğğ§ğ¥ğ¢ğ§ğ ğ€ğš ğ‰ğš ğ‘ğ ğ’ğ¨ğ§ğ  ğ’ğ®ğ§ğš ğ‘ğšğ¡ğ¢ ğ‡ğ®ğŸ˜»** ",
           " **ğˆğ§ğ¬ğ­ğšğ ğ«ğšğ¦ ğ‚ğ¡ğšğ¥ğšğ­ğ ğ‡ğ¨..??ğŸ™ƒ** ",
           " **ğ–ğ¡ğšğ­ğ¬ğšğ©ğ© ğğ®ğ¦ğ›ğğ« ğƒğ¨ğ ğ ğ€ğ©ğ§ğš ğ“ğ®ğ¦..?ğŸ˜•** ",
           " **ğ“ğ®ğ¦ğ¡ğ ğŠğ¨ğ§ ğ’ğš ğŒğ®ğ¬ğ¢ğœ ğ’ğ®ğ§ğ§ğš ğğšğ¬ğšğ§ğ ğ‡ğšğ¢..?ğŸ™ƒ** ",
           " **ğ’ğšğ«ğš ğŠğšğ¦ ğŠğ¡ğšğ­ğšğ¦ ğ‡ğ¨ ğ†ğ²ğš ğ€ğšğ©ğ¤ğš..?ğŸ™ƒ** ",
           " **ğŠğšğ¡ğš ğ’ğ ğ‡ğ¨ ğ€ğšğ©ğŸ˜Š** ",
           " **ğ’ğ®ğ§ğ¨ ğğšğŸ§** ",
           " **ğŒğğ«ğš ğ„ğ¤ ğŠğšğšğ¦ ğŠğšğ« ğƒğ¨ğ ğ..?** ",
           " **ğğ² ğ“ğšğ­ğš ğŒğšğ­ ğğšğ­ ğŠğšğ«ğ§ğš ğ€ğšğ£ ğŠğ ğğšğğŸ˜ ** ",
           " **ğŒğ¨ğ¦ ğƒğšğ ğŠğšğ¢ğ¬ğ ğ‡ğšğ¢ğ§..?â¤** ",
           " **ğŠğ²ğš ğ‡ğ®ğš..?ğŸ‘±** ",
           " **ğğ¨ğ¡ğ¨ğ­ ğ˜ğšğšğ ğ€ğš ğ‘ğ¡ğ¢ ğ‡ğšğ¢ ğŸ¤§â£ï¸** ",
           " **ğğ¡ğ®ğ¥ ğ†ğ²ğ ğŒğ®ğ£ğ¡ğğŸ˜ğŸ˜** ",
           " **ğ‰ğ®ğ­ğ¡ ğğ¡ğ¢ ğğ¨ğ¥ğ§ğš ğ‚ğ¡ğšğ¡ğ¢ğ²ğğŸ¤** ",
           " **ğŠğ¡ğš ğ‹ğ¨ ğğ¡ğšğ° ğŒğšğ­ ğŠğ«ğ¨ ğğšğšğ­ğŸ˜’** ",
           " **ğŠğ²ğš ğ‡ğ®ğšğŸ˜®ğŸ˜®** "
           " **ğ‡ğ¢ğ¢ğŸ‘€** ",
           " **ğ€ğšğ©ğ¤ğ ğ‰ğšğ¢ğ¬ğš ğƒğ¨ğ¬ğ­ ğ‡ğ¨ ğ’ğšğ­ğ¡ ğŒğ ğ…ğ¢ğ« ğ†ğ®ğ¦ ğŠğ¢ğ¬ ğğšğ­ ğŠğš ğŸ™ˆ** ",
           " **ğ€ğšğ£ ğŒğšğ¢ ğ’ğšğ ğ‡ğ® â˜¹ï¸** ",
           " **ğŒğ®ğ¬ğ£ğ¡ğ¬ğ ğğ¡ğ¢ ğğšğ­ ğŠğšğ« ğ‹ğ¨ ğğš ğŸ¥ºğŸ¥º** ",
           " **ğŠğ²ğš ğŠğšğ« ğ‘ğšğ¡ğ ğ‡ğ¨ğŸ‘€** ",
           " **ğŠğ²ğš ğ‡ğšğ¥ ğ‚ğ¡ğšğ¥ ğ‡ğšğ¢ ğŸ™‚** ",
           " **ğŠğšğ¡ğš ğ’ğ ğ‡ğ¨ ğ€ğšğ©..?ğŸ¤”** ",
           " **ğ‚ğ¡ğšğ­ğ­ğ¢ğ§ğ  ğŠğšğ« ğ‹ğ¨ ğğš..ğŸ¥º** ",
           " **ğŒğ ğŒğšğ¬ğ¨ğ¨ğ¦ ğ‡ğ® ğğšğŸ¥ºğŸ¥º** ",
           " **ğŠğšğ¥ ğŒğšğ£ğš ğ€ğ²ğš ğ“ğ¡ğš ğğšğŸ¤­ğŸ˜…** ",
           " **ğ†ğ«ğ¨ğ®ğ© ğŒğ ğğšğ­ ğŠğ²ğ® ğğšğ¡ğ¢ ğŠğšğ«ğ­ğ ğ‡ğ¨ğŸ˜•** ",
           " **ğ€ğšğ© ğ‘ğğ¥ğšğ­ğ¢ğ¨ğ¦ğ¬ğ¡ğ¢ğ© ğŒğ ğ‡ğ¨..?ğŸ‘€** ",
           " **ğŠğ¢ğ­ğ§ğš ğ‚ğ¡ğ®ğ© ğ‘ğšğ¡ğ­ğ ğ‡ğ¨ ğ˜ğ«ğ«ğŸ˜¼** ",
           " **ğ€ğšğ©ğ¤ğ¨ ğ†ğšğ§ğš ğ†ğšğ§ğ ğ€ğšğ­ğš ğ‡ğšğ¢..?ğŸ˜¸** ",
           " **ğ†ğ¡ğ®ğ¦ğ§ğ ğ‚ğ¡ğšğ¥ğ¨ğ ğ..??ğŸ™ˆ** ",
           " **ğŠğ¡ğ®ğ¬ ğ‘ğšğ¡ğš ğŠğšğ«ğ¨ âœŒï¸ğŸ¤** ",
           " **ğ‡ğšğ¦ ğƒğ¨ğ¬ğ­ ğğšğ§ ğ’ğšğ¤ğ­ğ ğ‡ğšğ¢...?ğŸ¥°** ",
           " **ğŠğ®ğœğ¡ ğğ¨ğ¥ ğŠğ²ğ® ğğ¡ğ¢ ğ‘ğšğ¡ğ ğ‡ğ¨..ğŸ¥ºğŸ¥º** ",
           " **ğŠğ®ğœğ¡ ğŒğğ¦ğ›ğğ«ğ¬ ğ€ğğ ğŠğšğ« ğƒğ¨ ğŸ¥²** ",
           " **ğ’ğ¢ğ§ğ ğ¥ğ ğ‡ğ¨ ğ˜ğš ğŒğ¢ğ§ğ ğ¥ğ ğŸ˜‰** ",
           " **ğ€ğšğ¨ ğğšğ«ğ­ğ² ğŠğšğ«ğ­ğ ğ‡ğšğ¢ğ§ğŸ˜‹ğŸ¥³** ",
           " **ğ‡ğğ¦ğ¥ğ¨ğ¨ğŸ§** ",
           " **ğŒğ®ğ£ğ¡ğ ğğ¡ğ®ğ¥ ğ†ğ²ğ ğŠğ²ğšğŸ¥º** ",
           " **ğ“ğ«ğ®ğ­ğ¡ ğ€ğ§ğ ğƒğšğ«ğ ğŠğ¡ğğ¥ğ¨ğ ğ..? ğŸ˜Š** ",
           " **ğ€ğšğ£ ğŒğ®ğ¦ğ¦ğ² ğğ ğƒğšğ­ğš ğ˜ğ«ğŸ¥ºğŸ¥º** ",
           " **ğ„ğ¤ ğƒğ¢ğ¥ ğ‡ğšğ¢ ğ„ğ¤ ğƒğ¢ğ¥ ğ‡ğ¢ ğ“ğ¨ ğ‡ğšğ¢ğŸ˜—ğŸ˜—** ",
           " **ğ“ğ®ğ¦ğ¡ğšğ«ğ ğƒğ¨ğ¬ğ­ ğŠğšğ¡ğš ğ†ğ²ğğŸ¥º** ",
           " **ğŒğ² ğ‚ğ®ğ­ğ ğğ°ğ§ğğ« [ @AM_YTBOTT ]ğŸ¥°** ",
           " **ğŠğšğ¡ğš ğŠğ¡ğ¨ğ²ğ ğ‡ğ¨ ğ‰ğšğšğ§ğŸ˜œ** ",
           " **ğ†ğ¨ğ¨ğ ğ8 ğ‰ğ¢ ğğ¡ğ®ğ­ ğ‘ğšğ­ ğ‡ğ¨ ğ ğ²ğ¢ğŸ¥°** ",
           ]

   
#TagOff     
@client.on_message(
    filters.command(["cancel", "stopall", "off"], prefixes=["/", ".", "?", "-", "", "!"])
    & filters.group
)
async def cancelcmd(_, message):
    chat_id = message.chat.id
    chat_member = await client.get_chat_member(message.chat.id, message.from_user.id)
    if chat_member.status not in ["administrator", "creator"]:
        return await message.reply_text("**Only admins can use this command!**")

    if chat_id in SPAM_CHATS:
        try:
            SPAM_CHATS.remove(chat_id)
        except Exception:
            pass
        return await message.reply_text("**Ok Yrr Ab Yesa Lagraha me spam karr jesa ab nahi tag karraha me kisi ko!**")
    else:
        await message.reply_text("**No ongoing process!**")
        return
# Command handler to get group status
@client.on_message(
    filters.command(["Groupinfo"], prefixes=["/", ".", "?", "-", "", "!"])
    & filters.group
)
def group_status(client, message):
    chat = message.chat  # Chat where the command was sent
    status_text = f"Group ID: {chat.id}\n" \
                  f"Title: {chat.title}\n" \
                  f"Type: {chat.type}\n"
                  
    if chat.username:  # Not all groups have a username
        status_text += f"Username: @{chat.username}"
    else:
        status_text += "Username: None"

    message.reply_text(status_text)


#########

""" ***                                                                       
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€â”€â”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â”€
â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€
â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ”€
â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€â”€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€**"""



####
@client.on_message(
    filters.command(["info"], prefixes=["/", ".", "?", "-", "", "!"])
    & filters.group
)
def group_info(client, message):
    chat_id = message.chat.id
    chat_info = app.get_chat(chat_id)
    title = chat_info.title
    description = chat_info.description
    member_count = chat_info.members_count

    info_text = f"Group Title: {title}\nDescription: {description}\nMembers Count: {member_count}"
    message.reply_text(info_text)

#help
@client.on_message(
    filters.command(["help"], prefixes=["/", ".", "?", "-", "", "!"])
    & ~filters.private
)
async def help_command(_, message):
    button_text = "É¢Ê™á´€É´êœ± ÊŸá´É¢êœ±"
    button_url = "https://t.me/Logs_Gban"
    button = InlineKeyboardButton(button_text, url=button_url)
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[button]])
    await message.reply_text(HELP, reply_markup=keyboard)

  #Repo  
@client.on_message(
    filters.command(["repo","source","code"], prefixes=["/", ".", "?", "-", "", "!",""])
    & ~filters.private
)
async def help_command(_, message):
    await message.reply_text(REPO)

#Bot
@client.on_message(
    filters.command(["bot"], prefixes=["/", ".", "?", "-", "", "!",""])
    & ~filters.private
)
async def help_command(_, message):
    text = random.choice(AAA)
    await message.reply_text(text)
#Tagall
@client.on_message(
    filters.command(["user", "invite"], prefixes=["/", ".", "?", "-", "", "!"])
    & filters.group
)
async def tag_all_users(_, message):
    chat_id = message.chat.id
    chat_member = await client.get_chat_member(message.chat.id, message.from_user.id)
    if chat_member.status not in ["administrator", "creator"]:
        return await message.reply_text("**Only admins can use this command!**")
    replied = message.reply_to_message
    if len(message.command) < 2 and not replied:
        await message.reply_text("**Reply to a message or give some text to tag all!**")
        return
    text = random.choice(TAGMES)
    SPAM_CHATS.append(message.chat.id)
    usernum = 0
    usertxt = ""
    members = await client.get_chat_members(message.chat.id)
    member_iter = iter(members)
    while message.chat.id in SPAM_CHATS:
        try:
            m = next(member_iter)
            usernum += 1
            usertxt += f" [{m.user.first_name}](tg://user?id={m.user.id})\n"
            if usernum == 1:
                if replied:
                    await replied.reply_text(usertxt)
                else:
                    await client.send_message(message.chat.id, f'{random.choice(TAGMES)}\n{usertxt}')
                await asyncio.sleep(10)
                usernum = 0
                usertxt = ""
        except StopIteration:
            break

    try:
        SPAM_CHATS.remove(message.chat.id)
    except Exception:
        pass

@client.on_chat_member_updated()
async def welcome_message(_, update):
    new_chat_member = update.new_chat_member
    if new_chat_member and new_chat_member.status == "member":
        welcome_text = f"Welcome {new_chat_member.mention} to the group! ğŸ‰"
        await client.send_message(update.chat.id, welcome_text)


#AM
@client.on_message(
    filters.command(["AM_YTBOTT","@AM_YTBOTT","@am_ytbott","ambot","am"], prefixes=["/", ".", "?", "-",""])
    & ~filters.private)
async def start(client, message):
    random_message = random.choice(AMTAGS)
    await message.reply_text(random_message)
    
@client.on_message(
    filters.text
    | filters.sticker
    & ~filters.private
    & ~filters.me
    & ~filters.bot,
)
async def Daxxai(client: Client, message: Message):

   chatdb = MongoClient(MONGO_URL)
   chatai = chatdb["Word"]["WordDb"]   

   if not message.reply_to_message:
       Daxxdb = MongoClient(MONGO_URL)
       Daxx = Daxxdb["DaxxDb"]["Daxx"] 
       is_Daxx = Daxx.find_one({"chat_id": message.chat.id})
       if not is_Daxx:
           await client.send_chat_action(message.chat.id, "typing")
           K = []  
           is_chat = chatai.find({"word": message.text})  
           k = chatai.find_one({"word": message.text})      
           if k:               
               for x in is_chat:
                   K.append(x['text'])          
               hey = random.choice(K)
               is_text = chatai.find_one({"text": hey})
               Yo = is_text['check']
               if Yo == "sticker":
                   await message.reply_sticker(f"{hey}")
               if not Yo == "sticker":
                   await message.reply_text(f"{hey}")
   
   if message.reply_to_message:  
       Daxxdb = MongoClient(MONGO_URL)
       Daxx = Daxxdb["DaxxDb"]["Daxx"] 
       is_Daxx = Daxx.find_one({"chat_id": message.chat.id})    
       getme = await client.get_me()
       user_id = getme.id                             
       if message.reply_to_message.from_user.id == user_id: 
           if not is_Daxx:                   
               await client.send_chat_action(message.chat.id, "typing")
               K = []  
               is_chat = chatai.find({"word": message.text})
               k = chatai.find_one({"word": message.text})      
               if k:       
                   for x in is_chat:
                       K.append(x['text'])
                   hey = random.choice(K)
                   is_text = chatai.find_one({"text": hey})
                   Yo = is_text['check']
                   if Yo == "sticker":
                       await message.reply_sticker(f"{hey}")
                   if not Yo == "sticker":
                       await message.reply_text(f"{hey}")
       if not message.reply_to_message.from_user.id == user_id:          
           if message.sticker:
               is_chat = chatai.find_one({"word": message.reply_to_message.text, "id": message.sticker.file_unique_id})
               if not is_chat:
                   chatai.insert_one({"word": message.reply_to_message.text, "text": message.sticker.file_id, "check": "sticker", "id": message.sticker.file_unique_id})
           if message.text:                 
               is_chat = chatai.find_one({"word": message.reply_to_message.text, "text": message.text})                 
               if not is_chat:
                   chatai.insert_one({"word": message.reply_to_message.text, "text": message.text, "check": "none"})                                                                                                                                               

@client.on_message(
 (
        filters.sticker
        | filters.text
    )
    & ~filters.private
    & ~filters.me
    & ~filters.bot,
)
async def Daxxstickerai(client: Client, message: Message):

   chatdb = MongoClient(MONGO_URL)
   chatai = chatdb["Word"]["WordDb"]   

   if not message.reply_to_message:
       Daxxdb = MongoClient(MONGO_URL)
       Daxx = Daxxdb["DaxxDb"]["Daxx"] 
       is_Daxx = Daxx.find_one({"chat_id": message.chat.id})
       if not is_Daxx:
           await client.send_chat_action(message.chat.id, "typing")
           K = []  
           is_chat = chatai.find({"word": message.sticker.file_unique_id})      
           k = chatai.find_one({"word": message.text})      
           if k:           
               for x in is_chat:
                   K.append(x['text'])
               hey = random.choice(K)
               is_text = chatai.find_one({"text": hey})
               Yo = is_text['check']
               if Yo == "text":
                   await message.reply_text(f"{hey}")
               if not Yo == "text":
                   await message.reply_sticker(f"{hey}")
   
   if message.reply_to_message:
       Daxxdb = MongoClient(MONGO_URL)
       Daxx = Daxxdb["DaxxDb"]["Daxx"] 
       is_Daxx = Daxx.find_one({"chat_id": message.chat.id})
       getme = await client.get_me()
       user_id = getme.id
       if message.reply_to_message.from_user.id == user_id: 
           if not is_Daxx:                    
               await client.send_chat_action(message.chat.id, "typing")
               K = []  
               is_chat = chatai.find({"word": message.text})
               k = chatai.find_one({"word": message.text})      
               if k:           
                   for x in is_chat:
                       K.append(x['text'])
                   hey = random.choice(K)
                   is_text = chatai.find_one({"text": hey})
                   Yo = is_text['check']
                   if Yo == "text":
                       await message.reply_text(f"{hey}")
                   if not Yo == "text":
                       await message.reply_sticker(f"{hey}")
       if not message.reply_to_message.from_user.id == user_id:          
           if message.text:
               is_chat = chatai.find_one({"word": message.reply_to_message.sticker.file_unique_id, "text": message.text})
               if not is_chat:
                   toggle.insert_one({"word": message.reply_to_message.sticker.file_unique_id, "text": message.text, "check": "text"})
           if message.sticker:                 
               is_chat = chatai.find_one({"word": message.reply_to_message.sticker.file_unique_id, "text": message.sticker.file_id})                 
               if not is_chat:
                   chatai.insert_one({"word": message.reply_to_message.sticker.file_unique_id, "text": message.sticker.file_id, "check": "none"})    
              


@client.on_message(
    (
        filters.text
        | filters.sticker
    )
    & filters.private
    & ~filters.me
    & ~filters.bot,
)
async def Daxxprivate(client: Client, message: Message):

   chatdb = MongoClient(MONGO_URL)
   chatai = chatdb["Word"]["WordDb"]
   if not message.reply_to_message: 
       await client.send_chat_action(message.chat.id, "typing")
       K = []  
       is_chat = chatai.find({"word": message.text})                 
       for x in is_chat:
           K.append(x['text'])
       hey = random.choice(K)
       is_text = chatai.find_one({"text": hey})
       Yo = is_text['check']
       if Yo == "sticker":
           await message.reply_sticker(f"{hey}")
       if not Yo == "sticker":
           await message.reply_text(f"{hey}")
   if message.reply_to_message:            
       getme = await client.get_me()
       user_id = getme.id       
       if message.reply_to_message.from_user.id == user_id:                    
           await client.send_chat_action(message.chat.id, "typing")
           K = []  
           is_chat = chatai.find({"word": message.text})                 
           for x in is_chat:
               K.append(x['text'])
           hey = random.choice(K)
           is_text = chatai.find_one({"text": hey})
           Yo = is_text['check']
           if Yo == "sticker":
               await message.reply_sticker(f"{hey}")
           if not Yo == "sticker":
               await message.reply_text(f"{hey}")
                     
@client.on_message(
 (
        filters.sticker
        | filters.text
    )
    & filters.private
    & ~filters.me
    & ~filters.bot,
)
async def Daxxprivatesticker(client: Client, message: Message):

   chatdb = MongoClient(MONGO_URL)
   chatai = chatdb["Word"]["WordDb"] 
   if not message.reply_to_message:
       await client.send_chat_action(message.chat.id, "typing")
       K = []  
       is_chat = chatai.find({"word": message.sticker.file_unique_id})                 
       for x in is_chat:
           K.append(x['text'])
       hey = random.choice(K)
       is_text = chatai.find_one({"text": hey})
       Yo = is_text['check']
       if Yo == "text":
           await message.reply_text(f"{hey}")
       if not Yo == "text":
           await message.reply_sticker(f"{hey}")
   if message.reply_to_message:            
       getme = await client.get_me()
       user_id = getme.id       
       if message.reply_to_message.from_user.id == user_id:                    
           await client.send_chat_action(message.chat.id, "typing")
           K = []  
           is_chat = chatai.find({"word": message.sticker.file_unique_id})                 
           for x in is_chat:
               K.append(x['text'])
           hey = random.choice(K)
           is_text = chatai.find_one({"text": hey})
           Yo = is_text['check']
           if Yo == "text":
               await message.reply_text(f"{hey}")
           if not Yo == "text":
               await message.reply_sticker(f"{hey}")
client.run()
